/*
 * Copyright 2014-2015 Red Hat, Inc. and/or its affiliates
 * and other contributors as indicated by the @author tags.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.hawkular.metrics.api.jaxrs.util;

import static com.google.common.util.concurrent.Futures.immediateFailedFuture;
import static com.google.common.util.concurrent.Futures.immediateFuture;

import java.net.URI;
import java.util.Collection;
import java.util.Map;
import java.util.Optional;

import javax.ws.rs.core.Response;
import javax.ws.rs.core.Response.Status;

import org.hawkular.metrics.api.jaxrs.ApiError;

import com.google.common.base.Function;
import com.google.common.util.concurrent.FutureFallback;
import com.google.common.util.concurrent.Futures;
import com.google.common.util.concurrent.ListenableFuture;

/**
 * Constants and methods to help create responses and response futures, or transform futures into responses.
 *
 * @author John Sanda
 */
public class ResponseUtils {
    /**
     * Transforms a {@link Void} into a {@link Status#OK} response.
     */
    public static final Function<Void, Response> MAP_VOID = v -> ok();
    /**
     * Transforms an {@link Optional} into a {@link Status#OK} response if the optional is present, {@link
     * Status#NO_CONTENT} if absent.
     */
    public static final Function<Optional<?>, Response> MAP_VALUE = o -> o.map(ResponseUtils::ok).orElse(noContent());
    /**
     * Transforms a {@link Collection} into a {@link Status#OK} response if the collection is not empty, {@link
     * Status#NO_CONTENT} otherwise.
     */
    public static final Function<Collection<?>, Response> MAP_COLLECTION = c -> c.isEmpty() ? noContent() : ok(c);
    /**
     * Transforms a {@link Map} into a {@link Status#OK} response if the map is not empty, {@link Status#NO_CONTENT}
     * otherwise.
     */
    public static final Function<Map<?, ?>, Response> MAP_MAP = m -> m.isEmpty() ? noContent() : ok(m);

    private static Response ok() {
        return Response.ok().build();
    }

    private static Response ok(Object entity) {
        return Response.ok(entity).build();
    }

    private static Response noContent() {
        return Response.noContent().build();
    }

    /**
     * @return a {@link Response} future with {@link Status#BAD_REQUEST} status and entity indicating that the expected
     * payload is empty
     */
    public static ListenableFuture<Response> emptyPayload() {
        return badRequest(new ApiError("Payload is empty"));
    }

    /**
     * @param error error entity describing the issue
     *
     * @return a {@link Response} future with {@link Status#BAD_REQUEST} status and {@code error} entity
     */
    public static ListenableFuture<Response> badRequest(ApiError error) {
        return immediateFuture(Response.status(Status.BAD_REQUEST).entity(error).build());
    }

    /**
     * @param error entity describing the issue
     *
     * @return a {@link Response} future with {@link Status#CONFLICT} status and {@code error} entity
     */
    public static ListenableFuture<Response> conflict(ApiError error) {
        return immediateFuture(Response.status(Status.CONFLICT).entity(error).build());
    }

    /**
     * @param exceptionType type of the exception indicating the resource already exists
     * @param errorFunction a function to build a resource already exists entity
     * @param <E>           exception class type parameter
     *
     * @return a {@link Response} future fallback with {@link Status#CONFLICT} status and entity generated by {@code
     * errorFunction}
     * @see Futures#withFallback(ListenableFuture, FutureFallback)
     */
    public static <E> FutureFallback<Response> alreadyExistsFallback(
            Class<E> exceptionType,
            Function<E, ApiError> errorFunction
    ) {
        return t -> exceptionType.isAssignableFrom(t.getClass())
                    ? conflict(errorFunction.apply(exceptionType.cast(t)))
                    : immediateFailedFuture(t);
    }

    /**
     * Transforms a {@link Void} into a {@link Status#CREATED} response and set the location header using the
     * supplied value.
     *
     * @param location the URI of the new resource
     *
     * @return a {@link Void} to a {@link Status#CREATED} response function
     */
    public static Function<Void, Response> created(URI location) {
        return (Void input) -> Response.created(location).build();
    }

    private ResponseUtils() {
        // Utility class
    }
}
