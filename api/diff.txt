Seulement dans metrics-api-jaxrs-1.1: hawkular-metrics-api-jaxrs-1.1.iml
Seulement dans metrics-api-jaxrs: hawkular-metrics-api-jaxrs.iml
diff -r '--exclude=target' metrics-api-jaxrs/pom.xml metrics-api-jaxrs-1.1/pom.xml
31c31
<   <artifactId>hawkular-metrics-api-jaxrs</artifactId>
---
>   <artifactId>hawkular-metrics-api-jaxrs-1.1</artifactId>
34,35c34,39
<   <name>Hawkular Metrics JAX-RS 2.0 API</name>
<   <description>JAX-RS 2.0 REST API Implementation</description>
---
>   <name>Hawkular Metrics JAX-RS 1.1 API</name>
>   <description>JAX-RS 1.1 REST API Implementation</description>
> 
>   <properties>
>     <enforcer.skip>true</enforcer.skip>
>   </properties>
40,43d43
<       <groupId>org.antlr</groupId>
<       <artifactId>antlr4-runtime</artifactId>
<     </dependency>
<     <dependency>
59c59
<     <!-- Wildfly provided -->
---
>     <!-- AS7 provided -->
62a63
>       <version>2.3.10.Final</version>
66,67c67,81
<       <groupId>org.jboss.resteasy</groupId>
<       <artifactId>resteasy-jackson2-provider</artifactId>
---
>       <groupId>com.fasterxml.jackson.core</groupId>
>       <artifactId>jackson-core</artifactId>
>       <version>2.3.0.redhat-4</version>
>       <scope>provided</scope>
>     </dependency>
>     <dependency>
>       <groupId>com.fasterxml.jackson.core</groupId>
>       <artifactId>jackson-databind</artifactId>
>       <version>2.3.0.redhat-4</version>
>       <scope>provided</scope>
>     </dependency>
>     <dependency>
>       <groupId>com.fasterxml.jackson.core</groupId>
>       <artifactId>jackson-annotations</artifactId>
>       <version>2.3.0.redhat-4</version>
72c86,87
<       <artifactId>jboss-servlet-api_3.1_spec</artifactId>
---
>       <artifactId>jboss-servlet-api_3.0_spec</artifactId>
>       <version>1.0.2.Final</version>
77a93
>       <version>1.0-SP4</version>
92,103d107
< 
<     <!-- test -->
<     <dependency>
<       <groupId>junit</groupId>
<       <artifactId>junit</artifactId>
<       <scope>test</scope>
<     </dependency>
<     <dependency>
<       <groupId>org.mockito</groupId>
<       <artifactId>mockito-core</artifactId>
<       <scope>test</scope>
<     </dependency>
105a110,116
>   <repositories>
>     <repository>
>       <id>eap_6_early_access</id>
>       <url>https://maven.repository.redhat.com/earlyaccess/all/</url>
>     </repository>
>   </repositories>
> 
107c118
<     <finalName>hawkular-metric-rest</finalName>
---
>     <finalName>hawkular-metrics-api-rest-1.1</finalName>
111,128d121
<         <groupId>org.antlr</groupId>
<         <artifactId>antlr4-maven-plugin</artifactId>
<         <executions>
<           <execution>
<             <id>antlr4</id>
<             <goals>
<               <goal>antlr4</goal>
<             </goals>
<             <phase>generate-sources</phase>
<             <configuration>
<               <listener>true</listener>
<               <visitor>true</visitor>
<             </configuration>
<           </execution>
<         </executions>
<       </plugin>
< 
<       <plugin>
163,223d155
<   <profiles>
<     <profile>
<       <id>docgen</id>
< 
<       <build>
<         <!-- Document generation from the Swagger annotations on the REST-API. -->
<         <plugins>
<           <plugin>
<             <groupId>org.apache.maven.plugins</groupId>
<             <artifactId>maven-dependency-plugin</artifactId>
<             <executions>
<               <execution>
<                 <id>unpack</id>
<                 <phase>process-resources</phase>
<                 <goals>
<                   <goal>unpack</goal>
<                 </goals>
<                 <configuration>
<                   <artifactItems>
<                     <artifactItem>
<                       <groupId>org.hawkular</groupId>
<                       <artifactId>hawkular-build-tools</artifactId>
<                       <version>${version.org.hawkular.hawkular-build-tools}</version>
<                       <type>jar</type>
<                       <includes>**/*.mustache</includes>
<                     </artifactItem>
<                   </artifactItems>
<                 </configuration>
<               </execution>
<             </executions>
<           </plugin>
<           <plugin>
<             <groupId>com.github.kongchen</groupId>
<             <artifactId>swagger-maven-plugin</artifactId>
<             <configuration>
<               <apiSources>
<                 <apiSource>
<                   <locations>org.hawkular.metrics.api.jaxrs</locations>
<                   <apiVersion>1.0</apiVersion>
<                   <basePath>http://localhost:8080/hawkular/metrics/</basePath>
<                   <outputTemplate>${project.build.directory}/dependency/hawkular-documentation/asciidoc.mustache</outputTemplate>
<                   <swaggerDirectory>${project.build.directory}/generated/swagger-ui</swaggerDirectory>
<                   <swaggerInternalFilter>org.hawkular.metrics.api.jaxrs.swagger.filter.JaxRsFilter</swaggerInternalFilter>
<                   <swaggerApiReader>com.wordnik.swagger.jaxrs.reader.DefaultJaxrsApiReader</swaggerApiReader>
<                   <outputPath>${project.build.directory}/generated/rest-metrics.adoc</outputPath>
<                 </apiSource>
<               </apiSources>
<             </configuration>
<             <executions>
<               <execution>
<                 <phase>compile</phase>
<                 <goals>
<                   <goal>generate</goal>
<                 </goals>
<               </execution>
<             </executions>
<           </plugin>
<         </plugins>
<       </build>
<     </profile>
<   </profiles>
Seulement dans metrics-api-jaxrs: README.adoc
Seulement dans metrics-api-jaxrs/src/main: antlr4
diff -r '--exclude=target' metrics-api-jaxrs/src/main/java/org/hawkular/metrics/api/jaxrs/config/ConfigurationKey.java metrics-api-jaxrs-1.1/src/main/java/org/hawkular/metrics/api/jaxrs/config/ConfigurationKey.java
36a37
> 
diff -r '--exclude=target' metrics-api-jaxrs/src/main/java/org/hawkular/metrics/api/jaxrs/exception/mappers/ExceptionMapperUtils.java metrics-api-jaxrs-1.1/src/main/java/org/hawkular/metrics/api/jaxrs/exception/mappers/ExceptionMapperUtils.java
20a21
> import javax.ws.rs.core.Response.ResponseBuilder;
34d34
<     private ExceptionMapperUtils(){
35a36,38
>     public static Response buildResponse(Throwable exception, int statusCode) {
>         ResponseBuilder responseBuilder = Response.status(statusCode);
>         return buildErrorResponse(exception, responseBuilder);
38c41,46
<     public static Response buildResponse(Throwable exception, Status status){
---
>     public static Response buildResponse(Throwable exception, Status status) {
>         ResponseBuilder responseBuilder = Response.status(status);
>         return buildErrorResponse(exception, responseBuilder);
>     }
> 
>     private static Response buildErrorResponse(Throwable exception, ResponseBuilder responseBuilder) {
40c48
<         return Response.status(status)
---
>         return responseBuilder
43a52,55
>     }
> 
>     private ExceptionMapperUtils() {
>         // Utility class
diff -r '--exclude=target' metrics-api-jaxrs/src/main/java/org/hawkular/metrics/api/jaxrs/exception/mappers/NotAcceptableExceptionMapper.java metrics-api-jaxrs-1.1/src/main/java/org/hawkular/metrics/api/jaxrs/exception/mappers/NotAcceptableExceptionMapper.java
19d18
< import javax.ws.rs.NotAcceptableException;
22a22,23
> 
> import org.jboss.resteasy.spi.NotAcceptableException;
diff -r '--exclude=target' metrics-api-jaxrs/src/main/java/org/hawkular/metrics/api/jaxrs/exception/mappers/NotAllowedExceptionMapper.java metrics-api-jaxrs-1.1/src/main/java/org/hawkular/metrics/api/jaxrs/exception/mappers/NotAllowedExceptionMapper.java
19d18
< import javax.ws.rs.NotAllowedException;
23a23,24
> import org.jboss.resteasy.spi.MethodNotAllowedException;
> 
33c34
< public class NotAllowedExceptionMapper implements ExceptionMapper<NotAllowedException> {
---
> public class NotAllowedExceptionMapper implements ExceptionMapper<MethodNotAllowedException> {
36,37c37,38
<     public Response toResponse(NotAllowedException exception) {
<         return ExceptionMapperUtils.buildResponse(exception, Response.Status.METHOD_NOT_ALLOWED);
---
>     public Response toResponse(MethodNotAllowedException exception) {
>         return ExceptionMapperUtils.buildResponse(exception, 405);
diff -r '--exclude=target' metrics-api-jaxrs/src/main/java/org/hawkular/metrics/api/jaxrs/exception/mappers/NotFoundExceptionMapper.java metrics-api-jaxrs-1.1/src/main/java/org/hawkular/metrics/api/jaxrs/exception/mappers/NotFoundExceptionMapper.java
19d18
< import javax.ws.rs.NotFoundException;
22a22,23
> 
> import org.jboss.resteasy.spi.NotFoundException;
diff -r '--exclude=target' metrics-api-jaxrs/src/main/java/org/hawkular/metrics/api/jaxrs/exception/mappers/NotSupportedExceptionMapper.java metrics-api-jaxrs-1.1/src/main/java/org/hawkular/metrics/api/jaxrs/exception/mappers/NotSupportedExceptionMapper.java
16a17
> 
19d19
< import javax.ws.rs.NotSupportedException;
23a24,25
> import org.jboss.resteasy.spi.UnsupportedMediaTypeException;
> 
33c35
< public class NotSupportedExceptionMapper implements ExceptionMapper<NotSupportedException> {
---
> public class NotSupportedExceptionMapper implements ExceptionMapper<UnsupportedMediaTypeException> {
36c38
<     public Response toResponse(NotSupportedException exception) {
---
>     public Response toResponse(UnsupportedMediaTypeException exception) {
diff -r '--exclude=target' metrics-api-jaxrs/src/main/java/org/hawkular/metrics/api/jaxrs/filter/CorsFilter.java metrics-api-jaxrs-1.1/src/main/java/org/hawkular/metrics/api/jaxrs/filter/CorsFilter.java
19,23d18
< import java.io.IOException;
< 
< import javax.ws.rs.container.ContainerRequestContext;
< import javax.ws.rs.container.ContainerResponseContext;
< import javax.ws.rs.container.ContainerResponseFilter;
26a22,25
> import org.jboss.resteasy.annotations.interception.ServerInterceptor;
> import org.jboss.resteasy.core.ServerResponse;
> import org.jboss.resteasy.spi.interception.PostProcessInterceptor;
> 
32c31,32
< public class CorsFilter implements ContainerResponseFilter {
---
> @ServerInterceptor
> public class CorsFilter implements PostProcessInterceptor {
38,41c38,39
<     public void filter(ContainerRequestContext requestContext,
<             ContainerResponseContext responseContext) throws IOException {
<         final MultivaluedMap<String, Object> headers = responseContext
<                 .getHeaders();
---
>     public void postProcess(ServerResponse response) {
>         final MultivaluedMap<String, Object> headers = response.getMetadata();
diff -r '--exclude=target' metrics-api-jaxrs/src/main/java/org/hawkular/metrics/api/jaxrs/filter/EmptyPayloadFilter.java metrics-api-jaxrs-1.1/src/main/java/org/hawkular/metrics/api/jaxrs/filter/EmptyPayloadFilter.java
20,21c20
< import java.io.IOException;
< 
---
> import javax.servlet.http.HttpServletRequest;
23,25c22,23
< import javax.ws.rs.container.ContainerRequestContext;
< import javax.ws.rs.container.ContainerRequestFilter;
< import javax.ws.rs.core.UriInfo;
---
> import javax.ws.rs.WebApplicationException;
> import javax.ws.rs.core.Context;
27a26,32
> import org.jboss.resteasy.annotations.interception.ServerInterceptor;
> import org.jboss.resteasy.core.ResourceMethod;
> import org.jboss.resteasy.core.ServerResponse;
> import org.jboss.resteasy.spi.Failure;
> import org.jboss.resteasy.spi.HttpRequest;
> import org.jboss.resteasy.spi.interception.PreProcessInterceptor;
> 
32a38
>  * @author Stefan Negrea
35c41,42
< public class EmptyPayloadFilter implements ContainerRequestFilter {
---
> @ServerInterceptor
> public class EmptyPayloadFilter implements PreProcessInterceptor {
37a45,47
>     @Context
>     HttpServletRequest servletRequest;
> 
39,48c49,54
<     public void filter(ContainerRequestContext requestContext) throws IOException {
<         if (!HttpMethod.POST.equals(requestContext.getMethod())) {
<             return;
<         }
<         UriInfo uriInfo = requestContext.getUriInfo();
<         String path = uriInfo.getPath();
<         if (path.startsWith("/db")) {
<             // Skip some endpoints:
<             // - Influx
<             return;
---
>     public ServerResponse preProcess(HttpRequest request,
>             ResourceMethod resourceMethod) throws Failure,
>             WebApplicationException {
> 
>         if (!HttpMethod.POST.equals(request.getHttpMethod())) {
>             return null;
50c56,58
<         requestContext.setProperty(EMPTY_PAYLOAD, Boolean.TRUE);
---
> 
>         servletRequest.setAttribute(EMPTY_PAYLOAD, Boolean.TRUE);
>         return null;
diff -r '--exclude=target' metrics-api-jaxrs/src/main/java/org/hawkular/metrics/api/jaxrs/filter/MetricsServiceStateFilter.java metrics-api-jaxrs-1.1/src/main/java/org/hawkular/metrics/api/jaxrs/filter/MetricsServiceStateFilter.java
21,22d20
< import java.io.IOException;
< 
24,25c22
< import javax.ws.rs.container.ContainerRequestContext;
< import javax.ws.rs.container.ContainerRequestFilter;
---
> import javax.ws.rs.WebApplicationException;
28d24
< import javax.ws.rs.core.UriInfo;
34a31,36
> import org.jboss.resteasy.annotations.interception.ServerInterceptor;
> import org.jboss.resteasy.core.ResourceMethod;
> import org.jboss.resteasy.core.ServerResponse;
> import org.jboss.resteasy.spi.Failure;
> import org.jboss.resteasy.spi.HttpRequest;
> import org.jboss.resteasy.spi.interception.PreProcessInterceptor;
40c42,43
< public class MetricsServiceStateFilter implements ContainerRequestFilter {
---
> @ServerInterceptor
> public class MetricsServiceStateFilter implements PreProcessInterceptor {
50,52c53,55
<     public void filter(ContainerRequestContext containerRequestContext) throws IOException {
<         UriInfo uriInfo = containerRequestContext.getUriInfo();
<         String path = uriInfo.getPath();
---
>     public ServerResponse preProcess(HttpRequest request, ResourceMethod method) throws Failure,
>             WebApplicationException {
>         String path = request.getUri().getPath();
56c59
<             return;
---
>             return null;
65c68
<             containerRequestContext.abortWith(response);
---
>             return ServerResponse.copyIfNotServerResponse(response);
72c75
<             containerRequestContext.abortWith(response);
---
>             return ServerResponse.copyIfNotServerResponse(response);
74c77
<                    metricsServiceLifecycle.getState() == State.STOPPING) {
---
>                 metricsServiceLifecycle.getState() == State.STOPPING) {
79c82
<             containerRequestContext.abortWith(response);
---
>             return ServerResponse.copyIfNotServerResponse(response);
80a84,85
> 
>         return null;
diff -r '--exclude=target' metrics-api-jaxrs/src/main/java/org/hawkular/metrics/api/jaxrs/filter/TenantFilter.java metrics-api-jaxrs-1.1/src/main/java/org/hawkular/metrics/api/jaxrs/filter/TenantFilter.java
19,22c19,21
< import org.hawkular.metrics.api.jaxrs.ApiError;
< import org.hawkular.metrics.api.jaxrs.handler.BaseHandler;
< import org.hawkular.metrics.api.jaxrs.handler.StatusHandler;
< import org.hawkular.metrics.api.jaxrs.handler.VirtualClockHandler;
---
> import static javax.ws.rs.core.MediaType.APPLICATION_JSON_TYPE;
> 
> import java.util.List;
24,25c23
< import javax.ws.rs.container.ContainerRequestContext;
< import javax.ws.rs.container.ContainerRequestFilter;
---
> import javax.ws.rs.WebApplicationException;
28d25
< import javax.ws.rs.core.UriInfo;
30d26
< import java.io.IOException;
32c28,37
< import static javax.ws.rs.core.MediaType.APPLICATION_JSON_TYPE;
---
> import org.hawkular.metrics.api.jaxrs.ApiError;
> import org.hawkular.metrics.api.jaxrs.handler.BaseHandler;
> import org.hawkular.metrics.api.jaxrs.handler.StatusHandler;
> import org.hawkular.metrics.api.jaxrs.handler.VirtualClockHandler;
> import org.jboss.resteasy.annotations.interception.ServerInterceptor;
> import org.jboss.resteasy.core.ResourceMethod;
> import org.jboss.resteasy.core.ServerResponse;
> import org.jboss.resteasy.spi.Failure;
> import org.jboss.resteasy.spi.HttpRequest;
> import org.jboss.resteasy.spi.interception.PreProcessInterceptor;
38c43,44
< public class TenantFilter implements ContainerRequestFilter {
---
> @ServerInterceptor
> public class TenantFilter implements PreProcessInterceptor {
50,52c56,58
<     public void filter(ContainerRequestContext requestContext) throws IOException {
<         UriInfo uriInfo = requestContext.getUriInfo();
<         String path = uriInfo.getPath();
---
>     public ServerResponse preProcess(HttpRequest request, ResourceMethod method) throws Failure,
>             WebApplicationException {
>         String path = request.getUri().getPath();
55c61
<             || path.equals(BaseHandler.PATH) || path.startsWith(VirtualClockHandler.PATH)) {
---
>                 || path.equals(BaseHandler.PATH) || path.startsWith(VirtualClockHandler.PATH)) {
57c63
<             return;
---
>             return null;
60c66,67
<         String tenant = requestContext.getHeaders().getFirst(TENANT_HEADER_NAME);
---
>         List<String> requestHeader = request.getHttpHeaders().getRequestHeader(TENANT_HEADER_NAME);
>         String tenant = requestHeader != null && !requestHeader.isEmpty() ? requestHeader.get(0) : null;
63c70
<             return;
---
>             return null;
68,71c75,78
<                                     .type(APPLICATION_JSON_TYPE)
<                                     .entity(new ApiError(MISSING_TENANT_MSG))
<                                     .build();
<         requestContext.abortWith(response);
---
>                 .type(APPLICATION_JSON_TYPE)
>                 .entity(new ApiError(MISSING_TENANT_MSG))
>                 .build();
>         return ServerResponse.copyIfNotServerResponse(response);
diff -r '--exclude=target' metrics-api-jaxrs/src/main/java/org/hawkular/metrics/api/jaxrs/handler/AvailabilityHandler.java metrics-api-jaxrs-1.1/src/main/java/org/hawkular/metrics/api/jaxrs/handler/AvailabilityHandler.java
21d20
< 
23,25d21
< 
< import static org.hawkular.metrics.api.jaxrs.filter.TenantFilter.TENANT_HEADER_NAME;
< import static org.hawkular.metrics.api.jaxrs.util.ApiUtils.badRequest;
29d24
< import static org.hawkular.metrics.api.jaxrs.util.ApiUtils.serverError;
35a31
> import java.util.Optional;
49,50d44
< import javax.ws.rs.container.AsyncResponse;
< import javax.ws.rs.container.Suspended;
56,57c50
< import org.hawkular.metrics.api.jaxrs.handler.observer.MetricCreatedObserver;
< import org.hawkular.metrics.api.jaxrs.handler.observer.ResultSetObserver;
---
> import org.hawkular.metrics.api.jaxrs.filter.TenantFilter;
66a60
> import org.hawkular.metrics.core.api.DataPoint;
67a62
> import org.hawkular.metrics.core.api.MetricAlreadyExistsException;
97c92
<     @HeaderParam(TENANT_HEADER_NAME)
---
>     @HeaderParam(TenantFilter.TENANT_HEADER_NAME)
111,112c106
<     public void createAvailabilityMetric(
<             @Suspended final AsyncResponse asyncResponse,
---
>     public Response createAvailabilityMetric(
117c111
<         Metric metric = new Metric(new MetricId(tenantId, AVAILABILITY, metricDefinition.getId()),
---
>         Metric<?> metric = new Metric<DataPoint<?>>(new MetricId(tenantId, AVAILABILITY, metricDefinition.getId()),
119c113,122
<         metricsService.createMetric(metric).subscribe(new MetricCreatedObserver(asyncResponse, location));
---
>         try {
>             Observable<Void> observable = metricsService.createMetric(metric);
>             observable.toBlocking().lastOrDefault(null);
>             return Response.created(location).build();
>         } catch (MetricAlreadyExistsException e) {
>             String message = "A metric with name [" + e.getMetric().getId().getName() + "] already exists";
>             return Response.status(Response.Status.CONFLICT).entity(new ApiError(message)).build();
>         } catch (Exception e) {
>             return ApiUtils.serverError(e);
>         }
130,133c133,135
<     public void getAvailabilityMetric(@Suspended final AsyncResponse asyncResponse,
<             @HeaderParam("tenantId") String tenantId, @PathParam("id") String id) {
< 
<         metricsService.findMetric(new MetricId(tenantId, AVAILABILITY, id))
---
>     public Response getAvailabilityMetric(@HeaderParam("tenantId") String tenantId, @PathParam("id") String id) {
>         try {
>             return metricsService.findMetric(new MetricId(tenantId, AVAILABILITY, id))
137c139,143
<                 .subscribe(asyncResponse::resume, t -> asyncResponse.resume(serverError(t)));
---
>                 .toBlocking()
>                 .firstOrDefault(null);
>         } catch (Exception e) {
>             return ApiUtils.serverError(e);
>         }
149,150c155
<     public void getAvailabilityMetricTags(
<             @Suspended final AsyncResponse asyncResponse,
---
>     public Response getAvailabilityMetricTags(
153,155c158,167
<         metricsService.getMetricTags(new MetricId(tenantId, AVAILABILITY, id)).subscribe(
<                 optional -> asyncResponse.resume(valueToResponse(optional)),
<                 t -> asyncResponse.resume(serverError(t)));
---
>         Observable<Optional<Map<String, String>>> something = metricsService
>                 .getMetricTags(new MetricId(tenantId, AVAILABILITY, id));
>         try {
>             return something
>                     .map(optional -> valueToResponse(optional))
>                     .toBlocking()
>                     .lastOrDefault(null);
>         } catch (Exception e) {
>             return ApiUtils.serverError(e);
>         }
157a170
> 
165,166c178
<     public void updateAvailabilityMetricTags(
<             @Suspended final AsyncResponse asyncResponse,
---
>     public Response updateAvailabilityMetricTags(
171c183,188
<         metricsService.addTags(metric, tags).subscribe(new ResultSetObserver(asyncResponse));
---
>         try {
>             metricsService.addTags(metric, tags).toBlocking().lastOrDefault(null);
>             return Response.ok().build();
>         } catch (Exception e) {
>             return ApiUtils.serverError(e);
>         }
182,183c199
<     public void deleteAvailabilityMetricTags(
<             @Suspended final AsyncResponse asyncResponse,
---
>     public Response deleteAvailabilityMetricTags(
188c204,210
<         metricsService.deleteTags(metric, tags.getTags()).subscribe(new ResultSetObserver(asyncResponse));
---
> 
>         try {
>             metricsService.deleteTags(metric, tags.getTags()).toBlocking().lastOrDefault(null);
>             return Response.ok().build();
>         } catch (Exception e) {
>             return ApiUtils.serverError(e);
>         }
200,201c222,223
<     public void addAvailabilityForMetric(
<             @Suspended final AsyncResponse asyncResponse, @PathParam("id") String id,
---
>     public Response addAvailabilityForMetric(
>             @PathParam("id") String id,
206c228,234
<         metricsService.addAvailabilityData(Observable.just(metric)).subscribe(new ResultSetObserver(asyncResponse));
---
> 
>         try {
>             metricsService.addAvailabilityData(Observable.just(metric)).toBlocking().lastOrDefault(null);
>             return Response.ok().build();
>         } catch (Exception e) {
>             return ApiUtils.serverError(e);
>         }
218,219c246
<     public void addAvailabilityData(
<             @Suspended final AsyncResponse asyncResponse,
---
>     public Response addAvailabilityData(
223,224c250,256
<         metricsService.addAvailabilityData(requestToAvailabilities(tenantId, availabilities))
<                 .subscribe(new ResultSetObserver(asyncResponse));
---
>         try {
>             metricsService.addAvailabilityData(requestToAvailabilities(tenantId, availabilities)).toBlocking()
>                     .lastOrDefault(null);
>             return Response.ok().build();
>         } catch (Exception e) {
>             return ApiUtils.serverError(e);
>         }
235,236c267
<     public void findAvailabilityDataByTags(
<             @Suspended final AsyncResponse asyncResponse,
---
>     public Response findAvailabilityDataByTags(
240c271
<             asyncResponse.resume(badRequest(new ApiError("Missing tags query")));
---
>             return ApiUtils.badRequest(new ApiError("Missing tags query"));
242,250c273,285
<             // @TODO Repeated code, refactor (in GaugeHandler also)
<             metricsService.findAvailabilityByTags(tenantId, tags.getTags()).subscribe(m -> {
<                 if (m.isEmpty()) {
<                     asyncResponse.resume(Response.noContent().build());
<                 } else {
<                     asyncResponse.resume(Response.ok(m).build());
<                 }
<             }, t -> asyncResponse.resume(Response.serverError().entity(new ApiError(t.getMessage())).build()));
< 
---
>             try {
>                 return metricsService.findAvailabilityByTags(tenantId, tags.getTags()).map(m -> {
>                     if (m.isEmpty()) {
>                         return ApiUtils.noContent();
>                     } else {
>                         return Response.ok(m).build();
>                     }
>                 })
>                         .toBlocking()
>                         .lastOrDefault(null);
>             } catch (Exception e) {
>                 return Response.serverError().entity(new ApiError(e.getMessage())).build();
>             }
266,267c301
<     public void findAvailabilityData(
<             @Suspended AsyncResponse asyncResponse,
---
>     public Response findAvailabilityData(
275a310
> 
281d315
< 
283c317,318
<             metricsService.findAvailabilityData(metricId, startTime, endTime, distinct)
---
>             try {
>                 return metricsService.findAvailabilityData(metricId, startTime, endTime, distinct)
287,292c322,327
<                     .subscribe(
<                             asyncResponse::resume,
<                             t -> {
<                                 logger.warn("Failed to fetch availability data", t);
<                                 serverError(t);
<                             });
---
>                     .toBlocking()
>                     .lastOrDefault(null);
>             } catch (Exception e) {
>                 logger.warn("Failed to fetch availability data", e);
>                 return ApiUtils.serverError(e);
>             }
294c329
<             asyncResponse.resume(badRequest(new ApiError("Both buckets and bucketDuration parameters are used")));
---
>             return ApiUtils.badRequest(new ApiError("Both buckets and bucketDuration parameters are used"));
304,305c339,346
<                 asyncResponse.resume(badRequest(new ApiError("Bucket: " + e.getMessage())));
<                 return;
---
>                 return ApiUtils.badRequest(new ApiError("Bucket: " + e.getMessage()));
>             }
>             try {
>                 return metricsService.findAvailabilityStats(metricId, startTime, endTime, buckets)
>                         .map(ApiUtils::collectionToResponse).toBlocking()
>                         .lastOrDefault(null);
>             } catch (Exception e) {
>                 return ApiUtils.serverError(e);
307,310d347
< 
<             metricsService.findAvailabilityStats(metricId, startTime, endTime, buckets)
<                 .map(ApiUtils::collectionToResponse)
<                 .subscribe(asyncResponse::resume, ApiUtils::serverError);
321,322c358
<     public void tagAvailabilityData(
<             @Suspended final AsyncResponse asyncResponse,
---
>     public Response tagAvailabilityData(
334c370,376
<         resultSetObservable.subscribe(new ResultSetObserver(asyncResponse));
---
> 
>         try {
>             resultSetObservable.toBlocking().lastOrDefault(null);
>             return Response.ok().build();
>         } catch (Exception e) {
>             return ApiUtils.serverError(e);
>         }
345,346c387
<     public void findTaggedAvailabilityData(
<             @Suspended final AsyncResponse asyncResponse,
---
>     public Response findTaggedAvailabilityData(
349,350c390,391
<         metricsService.findAvailabilityByTags(tenantId, tags.getTags())
<         .subscribe(m -> { // @TODO Repeated code, refactor and use Optional?
---
>         try {
>         return metricsService.findAvailabilityByTags(tenantId, tags.getTags()).map(m -> {
352c393
<                 asyncResponse.resume(Response.noContent().build());
---
>                 return ApiUtils.noContent();
354c395
<                 asyncResponse.resume(Response.ok(m).build());
---
>                 return Response.ok(m).build();
356c397,400
<         }, t -> asyncResponse.resume(Response.serverError().entity(new ApiError(t.getMessage())).build()));
---
>             }).toBlocking().lastOrDefault(null);
>         } catch (Exception e) {
>             return Response.serverError().entity(new ApiError(e.getMessage())).build();
>         }
diff -r '--exclude=target' metrics-api-jaxrs/src/main/java/org/hawkular/metrics/api/jaxrs/handler/BaseHandler.java metrics-api-jaxrs-1.1/src/main/java/org/hawkular/metrics/api/jaxrs/handler/BaseHandler.java
23d22
< import com.wordnik.swagger.annotations.ApiOperation;
31a31
> 
33a34,35
> import com.wordnik.swagger.annotations.ApiOperation;
> 
72a75
>         @SuppressWarnings("unused")
76a80
>         @SuppressWarnings("unused")
80a85
>         @SuppressWarnings("unused")
diff -r '--exclude=target' metrics-api-jaxrs/src/main/java/org/hawkular/metrics/api/jaxrs/handler/CounterHandler.java metrics-api-jaxrs-1.1/src/main/java/org/hawkular/metrics/api/jaxrs/handler/CounterHandler.java
28d27
< import static org.hawkular.metrics.core.api.MetricType.COUNTER_RATE;
42,43d40
< import javax.ws.rs.container.AsyncResponse;
< import javax.ws.rs.container.Suspended;
49,50d45
< import org.hawkular.metrics.api.jaxrs.handler.observer.MetricCreatedObserver;
< import org.hawkular.metrics.api.jaxrs.handler.observer.ResultSetObserver;
56a52
> import org.hawkular.metrics.core.api.MetricAlreadyExistsException;
106,107c102
<     public void createCounter(
<             @Suspended final AsyncResponse asyncResponse,
---
>     public Response createCounter(
114c109,118
<         metricsService.createMetric(metric).subscribe(new MetricCreatedObserver(asyncResponse, location));
---
>         try {
>             Observable<Void> observable = metricsService.createMetric(metric);
>             observable.toBlocking().lastOrDefault(null);
>             return Response.created(location).build();
>         } catch (MetricAlreadyExistsException e) {
>             String message = "A metric with name [" + e.getMetric().getId().getName() + "] already exists";
>             return Response.status(Response.Status.CONFLICT).entity(new ApiError(message)).build();
>         } catch (Exception e) {
>             return ApiUtils.serverError(e);
>         }
125,127c129,131
<     public void getCounter(@Suspended final AsyncResponse asyncResponse, @PathParam("id") String id) {
< 
<         metricsService.findMetric(new MetricId(tenantId, COUNTER, id))
---
>     public Response getCounter(@PathParam("id") String id) {
>         try {
>             return metricsService.findMetric(new MetricId(tenantId, COUNTER, id))
131c135,138
<                 .subscribe(asyncResponse::resume, t -> asyncResponse.resume(ApiUtils.serverError(t)));
---
>                 .toBlocking().lastOrDefault(null);
>         } catch (Exception e) {
>             return ApiUtils.serverError(e);
>         }
143,144c150
<     public void addData(@Suspended final AsyncResponse asyncResponse,
<                         @ApiParam(value = "List of metrics", required = true) List<Counter> counters
---
>     public Response addData(@ApiParam(value = "List of metrics", required = true) List<Counter> counters
147,148c153,158
<         Observable<Void> observable = metricsService.addCounterData(metrics);
<         observable.subscribe(new ResultSetObserver(asyncResponse));
---
>         try {
>             metricsService.addCounterData(metrics).toBlocking().lastOrDefault(null);
>             return Response.ok().build();
>         } catch (Exception e) {
>             return ApiUtils.serverError(e);
>         }
160,161c170
<     public void addData(
<             @Suspended final AsyncResponse asyncResponse,
---
>     public Response addData(
166,169c175,181
<         Metric<Long> metric = new Metric<>(new MetricId(tenantId, COUNTER, id),
<                                            requestToCounterDataPoints(data));
<         Observable<Void> observable = metricsService.addCounterData(Observable.just(metric));
<         observable.subscribe(new ResultSetObserver(asyncResponse));
---
>         Metric<Long> metric = new Metric<>(new MetricId(tenantId, COUNTER, id), requestToCounterDataPoints(data));
>         try {
>             metricsService.addCounterData(Observable.just(metric)).toBlocking().lastOrDefault(null);
>             return Response.ok().build();
>         } catch (Exception e) {
>             return ApiUtils.serverError(e);
>         }
182,183c194
<     public void findCounterData(
<             @Suspended AsyncResponse asyncResponse,
---
>     public Response findCounterData(
192c203,204
<         metricsService.findCounterData(new MetricId(tenantId, COUNTER, id), startTime, endTime)
---
>         try {
>             return metricsService.findCounterData(new MetricId(tenantId, COUNTER, id), startTime, endTime)
196,201c208,213
<                 .subscribe(
<                         asyncResponse::resume,
<                         t -> {
<                             logger.warn("Failed to fetch counter data", t);
<                             ApiUtils.serverError(t);
<                         });
---
>                 .toBlocking()
>                 .lastOrDefault(null);
>         } catch (Exception e) {
>             logger.warn("Failed to fetch counter data", e);
>             return ApiUtils.serverError(e);
>         }
217,218c229
<     public void findRate(
<         @Suspended AsyncResponse asyncResponse,
---
>     public Response findRate(
227c238,239
<         metricsService.findRateData(new MetricId(tenantId, COUNTER_RATE, id), startTime, endTime)
---
>         try  {
>             return metricsService.findRateData(new MetricId(tenantId, COUNTER, id), startTime, endTime)
231,236c243,248
<                 .subscribe(
<                         asyncResponse::resume,
<                         t -> {
<                             logger.warn("Failed to fetch counter rate data", t);
<                             ApiUtils.serverError(t);
<                         });
---
>                 .toBlocking()
>                 .lastOrDefault(null);
>         } catch (Exception e) {
>             logger.warn("Failed to fetch counter rate data", e);
>             return ApiUtils.serverError(e);
>         }
diff -r '--exclude=target' metrics-api-jaxrs/src/main/java/org/hawkular/metrics/api/jaxrs/handler/GaugeHandler.java metrics-api-jaxrs-1.1/src/main/java/org/hawkular/metrics/api/jaxrs/handler/GaugeHandler.java
21d20
< 
23d21
< 
46,47d43
< import javax.ws.rs.container.AsyncResponse;
< import javax.ws.rs.container.Suspended;
53,54d48
< import org.hawkular.metrics.api.jaxrs.handler.observer.MetricCreatedObserver;
< import org.hawkular.metrics.api.jaxrs.handler.observer.ResultSetObserver;
63a58
> import org.hawkular.metrics.core.api.MetricAlreadyExistsException;
92a88
>     @Produces(APPLICATION_JSON)
105,106c101
<     public void createGaugeMetric(
<             @Suspended final AsyncResponse asyncResponse,
---
>     public Response createGaugeMetric(
113c108,117
<         metricsService.createMetric(metric).subscribe(new MetricCreatedObserver(asyncResponse, location));
---
>         try {
>             Observable<Void> observable = metricsService.createMetric(metric);
>             observable.toBlocking().lastOrDefault(null);
>             return Response.created(location).build();
>         } catch (MetricAlreadyExistsException e) {
>             String message = "A metric with name [" + e.getMetric().getId().getName() + "] already exists";
>             return Response.status(Response.Status.CONFLICT).entity(new ApiError(message)).build();
>         } catch (Exception e) {
>             return ApiUtils.serverError(e);
>         }
116a121
>     @Produces(APPLICATION_JSON)
124,126c129,131
<     public void getGaugeMetric(@Suspended final AsyncResponse asyncResponse, @PathParam("id") String id) {
< 
<         metricsService.findMetric(new MetricId(tenantId, GAUGE, id))
---
>     public Response getGaugeMetric(@PathParam("id") String id) {
>         try {
>             return metricsService.findMetric(new MetricId(tenantId, GAUGE, id))
129,130c134,137
<                 .switchIfEmpty(Observable.just(ApiUtils.noContent()))
<                 .subscribe(asyncResponse::resume, t -> asyncResponse.resume(ApiUtils.serverError(t)));
---
>                 .switchIfEmpty(Observable.just(ApiUtils.noContent())).toBlocking().lastOrDefault(null);
>         } catch (Exception e) {
>             return ApiUtils.serverError(e);
>         }
133a141
>     @Produces(APPLICATION_JSON)
142,150c150,157
<     public void getGaugeMetricTags(
<             @Suspended final AsyncResponse asyncResponse,
<             @PathParam("id") String id
<     ) {
<         metricsService.getMetricTags(new MetricId(tenantId, GAUGE, id))
<                 .subscribe(
<                         optional -> asyncResponse.resume(ApiUtils.valueToResponse(optional)),
<                         t ->asyncResponse.resume(ApiUtils.serverError(t))
<                 );
---
>     public Response getGaugeMetricTags(@PathParam("id") String id) {
>         try {
>             return metricsService.getMetricTags(new MetricId(tenantId, GAUGE, id))
>                     .map(ApiUtils::valueToResponse)
>                     .toBlocking().lastOrDefault(null);
>         } catch (Exception e) {
>             return ApiUtils.serverError(e);
>         }
153a161
>     @Produces(APPLICATION_JSON)
160,161c168
<     public void updateGaugeMetricTags(
<             @Suspended final AsyncResponse asyncResponse,
---
>     public Response updateGaugeMetricTags(
166c173,178
<         metricsService.addTags(metric, tags).subscribe(new ResultSetObserver(asyncResponse));
---
>         try {
>             metricsService.addTags(metric, tags).toBlocking().lastOrDefault(null);
>             return Response.ok().build();
>         } catch (Exception e) {
>             return ApiUtils.serverError(e);
>         }
169a182
>     @Produces(APPLICATION_JSON)
177,178c190
<     public void deleteGaugeMetricTags(
<             @Suspended final AsyncResponse asyncResponse,
---
>     public Response deleteGaugeMetricTags(
182,183c194,200
<         Metric<Double> metric = new Metric<>(new MetricId(tenantId, GAUGE, id));
<         metricsService.deleteTags(metric, tags.getTags()).subscribe(new ResultSetObserver(asyncResponse));
---
>         try {
>             Metric<Double> metric = new Metric<>(new MetricId(tenantId, GAUGE, id));
>             metricsService.deleteTags(metric, tags.getTags()).toBlocking().lastOrDefault(null);
>             return Response.ok().build();
>         } catch (Exception e) {
>             return ApiUtils.serverError(e);
>         }
186a204
>     @Produces(APPLICATION_JSON)
195,196c213
<     public void addDataForMetric(
<             @Suspended final AsyncResponse asyncResponse,
---
>     public Response addDataForMetric(
202,203c219,224
<         Observable<Void> observable = metricsService.addGaugeData(Observable.just(metric));
<         observable.subscribe(new ResultSetObserver(asyncResponse));
---
>         try {
>             metricsService.addGaugeData(Observable.just(metric)).toBlocking().lastOrDefault(null);
>             return Response.ok().build();
>         } catch (Exception e) {
>             return ApiUtils.serverError(e);
>         }
206a228
>     @Produces(APPLICATION_JSON)
215,216c237
<     public void addGaugeData(@Suspended final AsyncResponse asyncResponse,
<                              @ApiParam(value = "List of metrics", required = true) List<Gauge> gauges
---
>     public Response addGaugeData(@ApiParam(value = "List of metrics", required = true) List<Gauge> gauges
219,220c240,245
<         Observable<Void> observable = metricsService.addGaugeData(metrics);
<         observable.subscribe(new ResultSetObserver(asyncResponse));
---
>         try {
>             metricsService.addGaugeData(metrics).toBlocking().lastOrDefault(null);
>             return Response.ok().build();
>         } catch (Exception e) {
>             return ApiUtils.serverError(e);
>         }
223a249
>     @Produces(APPLICATION_JSON)
230,233c256
<     public void findGaugeDataByTags(
<             @Suspended final AsyncResponse asyncResponse,
<             @ApiParam(value = "Tag list", required = true) @QueryParam("tags") Tags tags
<     ) {
---
>     public Response findGaugeDataByTags(@ApiParam(value = "Tag list", required = true) @QueryParam("tags") Tags tags) {
235c258
<             asyncResponse.resume(badRequest(new ApiError("Missing tags query")));
---
>             return badRequest(new ApiError("Missing tags query"));
237,243c260,270
<             metricsService.findGaugeDataByTags(tenantId, tags.getTags()).subscribe(m -> {
<                 if (m.isEmpty()) {
<                     asyncResponse.resume(Response.noContent().build());
<                 } else {
<                     asyncResponse.resume(Response.ok(m).build());
<                 }
<             }, t -> asyncResponse.resume(Response.serverError().entity(new ApiError(t.getMessage())).build()));
---
>             try{
>                 return metricsService.findGaugeDataByTags(tenantId, tags.getTags()).map(m -> {
>                     if (m.isEmpty()) {
>                         return ApiUtils.noContent();
>                     } else {
>                         return Response.ok(m).build();
>                     }
>                 }).toBlocking().lastOrDefault(null);
>             } catch (Exception e) {
>                 return Response.serverError().entity(new ApiError(e.getMessage())).build();
>             }
248a276
>     @Produces(APPLICATION_JSON)
259,260c287
<     public void findGaugeData(
<             @Suspended AsyncResponse asyncResponse,
---
>     public Response findGaugeData(
274,278c301,311
<             metricsService.findGaugeData(metricId, startTime, endTime)
<                     .map(GaugeDataPoint::new)
<                     .toList()
<                     .map(ApiUtils::collectionToResponse)
<                     .subscribe(asyncResponse::resume, t -> asyncResponse.resume(ApiUtils.serverError(t)));
---
>             try {
>                 return metricsService
>                         .findGaugeData(metricId, startTime, endTime)
>                         .map(GaugeDataPoint::new)
>                         .toList()
>                         .map(ApiUtils::collectionToResponse)
>                         .toBlocking()
>                         .lastOrDefault(null);
>             } catch (Exception e) {
>                 return ApiUtils.serverError(e);
>             }
280c313
<             asyncResponse.resume(badRequest(new ApiError("Both buckets and bucketDuration parameters are used")));
---
>             return badRequest(new ApiError("Both buckets and bucketDuration parameters are used"));
290,291c323
<                 asyncResponse.resume(badRequest(new ApiError("Bucket: " + e.getMessage())));
<                 return;
---
>                 return badRequest(new ApiError("Bucket: " + e.getMessage()));
294,296c326,334
<             metricsService.findGaugeStats(metricId, startTime, endTime, buckets)
<                     .map(ApiUtils::collectionToResponse)
<                     .subscribe(asyncResponse::resume, t -> asyncResponse.resume(ApiUtils.serverError(t)));
---
>             try {
>                 return metricsService
>                         .findGaugeStats(metricId, startTime, endTime, buckets)
>                         .map(ApiUtils::collectionToResponse)
>                         .toBlocking()
>                         .lastOrDefault(null);
>             } catch (Exception e) {
>                 return ApiUtils.serverError(e);
>             }
300a339
>     @Produces(APPLICATION_JSON)
307,308c346
<     public void findPeriods(
<             @Suspended final AsyncResponse asyncResponse,
---
>     public Response findPeriods(
354,359c392,393
<             asyncResponse.resume(badRequest(
<                     new ApiError(
<                             "Invalid value for op parameter. Supported values are lt, "
<                                     + "lte, eq, gt, gte."
<                     )
<             ));
---
>             return badRequest(
>                     new ApiError("Invalid value for op parameter. Supported values are lt, lte, eq, gt, gte."));
361,363c395,400
<             metricsService.getPeriods(new MetricId(tenantId, GAUGE, id), predicate, startTime, endTime)
<                     .map(ApiUtils::collectionToResponse)
<                     .subscribe(asyncResponse::resume, t -> asyncResponse.resume(ApiUtils.serverError(t)));
---
>             try {
>                 return metricsService.getPeriods(new MetricId(tenantId, GAUGE, id), predicate, startTime, endTime)
>                         .map(ApiUtils::collectionToResponse).toBlocking().lastOrDefault(null);
>             } catch (Exception e) {
>                 return ApiUtils.serverError(e);
>             }
367a405
>     @Produces(APPLICATION_JSON)
374,386c412,426
<     public void findTaggedGaugeData(
<             @Suspended final AsyncResponse asyncResponse,
<             @ApiParam("Tag list") @PathParam("tags") Tags tags
<     ) {
<         metricsService.findGaugeDataByTags(tenantId, tags.getTags())
<             .flatMap(input -> Observable.from(input.entrySet())).toMap(e -> e.getKey().getName(), e2 -> e2.getValue())
<             .subscribe(m -> { // @TODO Repeated code
<                     if (m.isEmpty()) {
<                         asyncResponse.resume(Response.noContent().build());
<                     } else {
<                         asyncResponse.resume(Response.ok(m).build());
<                     }
<                 }, t -> asyncResponse.resume(ApiUtils.serverError(t)));
---
>     public Response findTaggedGaugeData(@ApiParam("Tag list") @PathParam("tags") Tags tags) {
>         try {
>             return metricsService.findGaugeDataByTags(tenantId, tags.getTags())
>                     .flatMap(input -> Observable.from(input.entrySet()))
>                     .toMap(e -> e.getKey().getName(), e2 -> e2.getValue())
>                     .map(m -> {
>                         if (m.isEmpty()) {
>                         return ApiUtils.noContent();
>                         } else {
>                             return Response.ok(m).build();
>                         }
>                     }).toBlocking().lastOrDefault(null);
>         } catch (Exception e) {
>             return ApiUtils.serverError(e);
>         }
389a430
>     @Produces(APPLICATION_JSON)
397,400c438
<     public void tagGaugeData(
<             @Suspended final AsyncResponse asyncResponse,
<             @PathParam("id") final String id, @ApiParam(required = true) TagRequest params
<     ) {
---
>     public Response tagGaugeData(@PathParam("id") final String id, @ApiParam(required = true) TagRequest params) {
409c447,452
<         resultSetObservable.subscribe(new ResultSetObserver(asyncResponse));
---
>         try {
>             resultSetObservable.toBlocking().lastOrDefault(null);
>             return Response.ok().build();
>         } catch (Exception e) {
>             return ApiUtils.serverError(e);
>         }
diff -r '--exclude=target' metrics-api-jaxrs/src/main/java/org/hawkular/metrics/api/jaxrs/handler/MetricHandler.java metrics-api-jaxrs-1.1/src/main/java/org/hawkular/metrics/api/jaxrs/handler/MetricHandler.java
23d22
< import static org.hawkular.metrics.api.jaxrs.util.ApiUtils.emptyPayload;
31d29
< 
32a31
> 
41,42d39
< import javax.ws.rs.container.AsyncResponse;
< import javax.ws.rs.container.Suspended;
76a74
> 
82a81
>     @SuppressWarnings("rawtypes")
94,95c93
<     public void findMetrics(
<             @Suspended final AsyncResponse asyncResponse,
---
>     public Response findMetrics(
103,104c101
<             asyncResponse.resume(badRequest(new ApiError("Incorrect type param " + metricType.toString())));
<             return;
---
>             return badRequest(new ApiError("Incorrect type param " + metricType.toString()));
110,120c107,118
<         metricObservable
<                 .map(MetricDefinition::new)
<                 .toList()
<                 .map(ApiUtils::collectionToResponse)
<                 .subscribe(asyncResponse::resume, t -> {
<                     if(t instanceof PatternSyntaxException) {
<                         asyncResponse.resume(ApiUtils.badRequest(t));
<                     } else {
<                         asyncResponse.resume(ApiUtils.serverError(t));
<                     }
<                 });
---
>         try {
>             return metricObservable
>                     .map(MetricDefinition::new)
>                     .toList()
>                     .map(ApiUtils::collectionToResponse)
>                     .toBlocking()
>                     .lastOrDefault(null);
>         } catch (PatternSyntaxException e) {
>             return ApiUtils.badRequest(e);
>         } catch (Exception e) {
>             return ApiUtils.serverError(e);
>         }
132,133c130
<     public void addMetricsData(
<             @Suspended final AsyncResponse asyncResponse,
---
>     public Response addMetricsData(
142,143c139
<             asyncResponse.resume(emptyPayload());
<             return;
---
>             return ApiUtils.emptyPayload();
164,168c160,165
<         Observable.merge(observables).subscribe(
<                 aVoid -> {},
<                 t -> asyncResponse.resume(ApiUtils.serverError(t)),
<                 () -> asyncResponse.resume(Response.ok().build())
<         );
---
>         try {
>             Observable.merge(observables).toBlocking().lastOrDefault(null);
>             return Response.ok().build();
>         } catch (Exception e) {
>             return ApiUtils.serverError(e);
>         }
Seulement dans metrics-api-jaxrs/src/main/java/org/hawkular/metrics/api/jaxrs/handler: observer
diff -r '--exclude=target' metrics-api-jaxrs/src/main/java/org/hawkular/metrics/api/jaxrs/handler/TenantsHandler.java metrics-api-jaxrs-1.1/src/main/java/org/hawkular/metrics/api/jaxrs/handler/TenantsHandler.java
21,23d20
< import static org.hawkular.metrics.api.jaxrs.util.ApiUtils.collectionToResponse;
< import static org.hawkular.metrics.api.jaxrs.util.ApiUtils.serverError;
< 
32,33d28
< import javax.ws.rs.container.AsyncResponse;
< import javax.ws.rs.container.Suspended;
34a30
> import javax.ws.rs.core.Response;
38d33
< import org.hawkular.metrics.api.jaxrs.handler.observer.TenantCreatedObserver;
39a35
> import org.hawkular.metrics.api.jaxrs.util.ApiUtils;
41a38
> import org.hawkular.metrics.core.api.TenantAlreadyExistsException;
48a46,47
> import rx.Observable;
> 
58,59d56
<     // TODO: add back retention settings
< 
76,77c73
<     public void createTenant(
<             @Suspended AsyncResponse asyncResponse, @ApiParam(required = true) TenantParam params,
---
>     public Response createTenant(@ApiParam(required = true) TenantParam params,
81,82c77,86
<         metricsService.createTenant(new Tenant(params.getId())).subscribe(new TenantCreatedObserver(asyncResponse,
<                 location));
---
>         try {
>             Observable<Void> observable = metricsService.createTenant(new Tenant(params.getId()));
>             observable.toBlocking().lastOrDefault(null);
>             return Response.created(location).build();
>         } catch (TenantAlreadyExistsException e) {
>             String message = "A tenant with id [" + e.getTenantId() + "] already exists";
>             return Response.status(Response.Status.CONFLICT).entity(new ApiError(message)).build();
>         } catch (Exception e) {
>             return ApiUtils.serverError(e);
>         }
93,94c97,100
<     public void findTenants(@Suspended AsyncResponse asyncResponse) {
<         metricsService.getTenants()
---
>     public Response findTenants() {
>         try {
>         return metricsService
>                 .getTenants()
96,99c102,108
<                 .toList().subscribe(
<                 tenants -> asyncResponse.resume(collectionToResponse(tenants)),
<                 error -> asyncResponse.resume(serverError(error))
<         );
---
>                 .toList()
>                 .map(ApiUtils::collectionToResponse)
>                 .toBlocking()
>                 .lastOrDefault(null);
>         } catch (Exception e) {
>             return ApiUtils.serverError(e);
>         }
diff -r '--exclude=target' metrics-api-jaxrs/src/main/java/org/hawkular/metrics/api/jaxrs/HawkularMetricsRestApp.java metrics-api-jaxrs-1.1/src/main/java/org/hawkular/metrics/api/jaxrs/HawkularMetricsRestApp.java
44d43
< import org.hawkular.metrics.api.jaxrs.influx.InfluxSeriesHandler;
46,47c45,47
< import org.hawkular.metrics.api.jaxrs.param.ConvertersProvider;
< import org.hawkular.metrics.api.jaxrs.util.JacksonConfig;
---
> import org.hawkular.metrics.api.jaxrs.param.DurationConverter;
> import org.hawkular.metrics.api.jaxrs.param.MetricTypeConverter;
> import org.hawkular.metrics.api.jaxrs.param.TagsConverter;
78d77
<         classes.add(InfluxSeriesHandler.class);
117,118c116,118
<         classes.add(ConvertersProvider.class);
<         classes.add(JacksonConfig.class);
---
>         classes.add(DurationConverter.class);
>         classes.add(MetricTypeConverter.class);
>         classes.add(TagsConverter.class);
Seulement dans metrics-api-jaxrs/src/main/java/org/hawkular/metrics/api/jaxrs: influx
diff -r '--exclude=target' metrics-api-jaxrs/src/main/java/org/hawkular/metrics/api/jaxrs/interceptor/EmptyPayloadInterceptor.java metrics-api-jaxrs-1.1/src/main/java/org/hawkular/metrics/api/jaxrs/interceptor/EmptyPayloadInterceptor.java
21d20
< 
30,31c29,32
< import javax.ws.rs.ext.ReaderInterceptor;
< import javax.ws.rs.ext.ReaderInterceptorContext;
---
> 
> import org.jboss.resteasy.annotations.interception.ServerInterceptor;
> import org.jboss.resteasy.spi.interception.MessageBodyReaderContext;
> import org.jboss.resteasy.spi.interception.MessageBodyReaderInterceptor;
37a39
>  * @author Stefan Negrea
41c43,44
< public class EmptyPayloadInterceptor implements ReaderInterceptor {
---
> @ServerInterceptor
> public class EmptyPayloadInterceptor implements MessageBodyReaderInterceptor {
44c47
<     public Object aroundReadFrom(ReaderInterceptorContext context) throws IOException, WebApplicationException {
---
>     public Object read(MessageBodyReaderContext context) throws IOException, WebApplicationException {
46c49
<         if (context.getProperty(EMPTY_PAYLOAD) != TRUE) {
---
>         if (context.getAttribute(EMPTY_PAYLOAD) != TRUE) {
diff -r '--exclude=target' metrics-api-jaxrs/src/main/java/org/hawkular/metrics/api/jaxrs/MetricsServiceLifecycle.java metrics-api-jaxrs-1.1/src/main/java/org/hawkular/metrics/api/jaxrs/MetricsServiceLifecycle.java
22d21
< 
327c326
< }
---
> }
\ Pas de fin de ligne  la fin du fichier
Seulement dans metrics-api-jaxrs/src/main/java/org/hawkular/metrics/api/jaxrs/param: ConvertersProvider.java
diff -r '--exclude=target' metrics-api-jaxrs/src/main/java/org/hawkular/metrics/api/jaxrs/param/DurationConverter.java metrics-api-jaxrs-1.1/src/main/java/org/hawkular/metrics/api/jaxrs/param/DurationConverter.java
26c26,28
< import javax.ws.rs.ext.ParamConverter;
---
> import javax.ws.rs.ext.Provider;
> 
> import org.jboss.resteasy.spi.StringConverter;
35c37,38
< public class DurationConverter implements ParamConverter<Duration> {
---
> @Provider
> public class DurationConverter implements StringConverter<Duration> {
diff -r '--exclude=target' metrics-api-jaxrs/src/main/java/org/hawkular/metrics/api/jaxrs/param/MetricTypeConverter.java metrics-api-jaxrs-1.1/src/main/java/org/hawkular/metrics/api/jaxrs/param/MetricTypeConverter.java
16a17
> 
19c20
< import javax.ws.rs.ext.ParamConverter;
---
> import javax.ws.rs.ext.Provider;
21a23
> import org.jboss.resteasy.spi.StringConverter;
28c30,31
< public class MetricTypeConverter implements ParamConverter<MetricType> {
---
> @Provider
> public class MetricTypeConverter implements StringConverter<MetricType> {
diff -r '--exclude=target' metrics-api-jaxrs/src/main/java/org/hawkular/metrics/api/jaxrs/param/TagsConverter.java metrics-api-jaxrs-1.1/src/main/java/org/hawkular/metrics/api/jaxrs/param/TagsConverter.java
27c27,29
< import javax.ws.rs.ext.ParamConverter;
---
> import javax.ws.rs.ext.Provider;
> 
> import org.jboss.resteasy.spi.StringConverter;
35c37,38
< public class TagsConverter implements ParamConverter<Tags> {
---
> @Provider
> public class TagsConverter implements StringConverter<Tags> {
Seulement dans metrics-api-jaxrs/src/main/java/org/hawkular/metrics/api/jaxrs: swagger
Seulement dans metrics-api-jaxrs/src/main/java/org/hawkular/metrics/api/jaxrs/util: JacksonConfig.java
Seulement dans metrics-api-jaxrs-1.1/src/main/java/org/hawkular/metrics/api/jaxrs/util: JacksonContextResolver.java
Seulement dans metrics-api-jaxrs/src/main/java/org/hawkular/metrics/api/jaxrs/util: SimpleLink.java
Seulement dans metrics-api-jaxrs/src/main/resources: rest-doc
Seulement dans metrics-api-jaxrs-1.1/src/main/webapp: favicon.ico
Seulement dans metrics-api-jaxrs-1.1/src/main/webapp: hawkular_logo.png
Seulement dans metrics-api-jaxrs-1.1/src/main/webapp: index.html
Seulement dans metrics-api-jaxrs/src/main/webapp: static
Seulement dans metrics-api-jaxrs-1.1/src/main/webapp: status.js
diff -r '--exclude=target' metrics-api-jaxrs/src/main/webapp/WEB-INF/jboss-deployment-structure.xml metrics-api-jaxrs-1.1/src/main/webapp/WEB-INF/jboss-deployment-structure.xml
22,25d21
<     <exclusions>
<       <module name="org.jboss.resteasy.resteasy-jackson-provider"/>
<       <module name="org.jboss.resteasy.resteasy-jettison-provider"/>
<     </exclusions>
27c23,24
<       <module name="org.jboss.resteasy.resteasy-jackson2-provider" services="import"/>
---
>       <module name="org.codehaus.jackson.jackson-core-asl" />
>       <module name="org.codehaus.jackson.jackson-mapper-asl" />
diff -r '--exclude=target' metrics-api-jaxrs/src/main/webapp/WEB-INF/web.xml metrics-api-jaxrs-1.1/src/main/webapp/WEB-INF/web.xml
25c25
<   <display-name>Hawkular Metrics Rest interface</display-name>
---
>   <display-name>Hawkular Metrics Rest interface - JAX-RS 1.1</display-name>
41c41
<     <param-value>org.hawkular.metrics.api.jaxrs.util.JacksonConfig</param-value>
---
>     <param-value>org.hawkular.metrics.api.jaxrs.util.JacksonContextResolver</param-value>
46c46
<     <servlet-class>io.undertow.servlet.handlers.DefaultServlet</servlet-class>
---
>     <servlet-class>org.apache.catalina.servlets.DefaultServlet</servlet-class>
48,49c48,49
<       <param-name>resolve-against-context-root</param-name>
<       <param-value>true</param-value>
---
>       <param-name>listings</param-name>
>       <param-value>false</param-value>
Seulement dans metrics-api-jaxrs-1.1/src/main/webapp: welcome.css
Seulement dans metrics-api-jaxrs/src/main: xsl
Seulement dans metrics-api-jaxrs/src: test
